## Counting permutations with Bitmask dp
I'll try to explain why you don't need to go through all the permutations, then maybe the DP solution will start making sense. The key idea, like in every other DP problem, is that you don't need to know the exact intermediate state (in this case, the prefix of the permutation) to be able to compute the answer for the whole problem. Instead, you can define features of intermediate state that are important for your problem -- in this case, the subset of digits that have been used and the remainder modulo M that this prefix has. Two prefixes that consist of the same subset of digits and have the same remainder will "behave" in the same way with regard to the function you are trying to compute (i.e., the number of permutations that divide by M).

This probably didn't make so much sense to you, so let's look at an example. Suppose M = 7 and N = 1122334. Look at the following two prefixes, both comprised of (multi)set {1, 2, 2, 3, 3}: 31232 and 12332. They both have remainder 5 modulo M = 7. You obviously have the same set of numbers that can be appended to these prefixes. On the other hand, for any digit X, when you append it to either of this prefixes, the resulting remainder will be the same for both of them. For example X = 1: , . If this confuses you, think about the rules of how modulo operation behaves for multiplication: , therefore the exact value of A does not matter, only  does. Hence, you don't care any more if it was prefix 31232 or 12332 that you were trying to complete, the number of ways to complete it will be the same. This means that you could count how many prefixes are there comprised of {1, 2, 2, 3, 3} with remainder 5 modulo M and see in how many ways any of them can be completed and multiply these two numbers, instead of computing the number of ways to complete every one of these prefixes.
